#+TITLE: AQS exclusive acquires
以 exclusive 方式 acquires 的 template method 最主要的方法有以下:
#+begin_src java
public final void acquire(int arg);
public final void acquireInterruptibly(int arg) throws InterruptedException;
public final boolean tryAcquireNanos(int arg, long nanosTimeout) throws InterruptedException;
#+end_src

這些方法在內部會調用兩種方法, 這些方法構成完整的 template workflow:
1. 其他 template method, 由 AQS 實現, 對修改關閉
2. template hook method, 由 subclass Sync 實現, 對修改開放

由於 template hook method 由 Sync 實現, 我們在討論各種工具類實再做介紹。 在這裡我們先列出 acquires template method 都可能會調用的其他 template methods:
#+begin_src java
private Node addWaiter(Node mode);
private Node enq(final Node node);
final boolean acquireQueued(final Node node, int arg);
private static boolean shouldParkAfterFailedAcquire(Node pred, Node node);
private final boolean parkAndCheckInterrupt();
#+end_src

+ [[acquire(int arg)][acquire(int arg)]]
+ [[acquireInterruptibly(int arg)][acquireInterruptibly(int arg)]]
+ [[tryAcquireNanos(int arg, long nanosTimeout)][tryAcquireNanos(int arg, long nanosTimeout)]]

* acquire(int arg)
acquire 自旋過程中, 如果收到 interrupt 信號, 會推遲到成功 tryAcquire 時才響應
#+begin_src java
    /**
     * Acquires in exclusive mode, ignoring interrupts.  Implemented
     * by invoking at least once {@link #tryAcquire},
     * returning on success.  Otherwise the thread is queued, possibly
     * repeatedly blocking and unblocking, invoking {@link
     * #tryAcquire} until success.  This method can be used
     * to implement method {@link Lock#lock}.
     *
     * @param arg the acquire argument.  This value is conveyed to
     *        {@link #tryAcquire} but is otherwise uninterpreted and
     *        can represent anything you like.
     */
    public final void acquire(int arg) {
        if (!tryAcquire(arg) &&
            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
            selfInterrupt();
    }
#+end_src
執行順序如下:
- [[*tryAcquire(arg)][tryAcquire(arg)]]
- [[*addWaiter(mode)][addWaiter(mode)]]
  - [[*enq(node)][enq(node)]]
- [[*acquireQueued(node, arg)][acquireQueued(node, arg)]]
  - [[*shouldParkAfterFailedAcquire(p, node)][shouldParkAfterFailedAcquire(p, node)]]
  - [[*parkAndCheckInterrupt()][parkAndCheckInterrupt()]]
- [[*selfInterrupt()][selfInterrupt()]]
** tryAcquire(arg)
#+begin_src java
protected boolean tryAcquire(int arg) {
    throw new UnsupportedOperationException();
}
#+end_src
=tryAcquire(arg)= 是由 =Sync= 實現的 template hook method。 當 =acquire(arg)= 執行時, 會首先嘗試 =tryAcquire(arg)=, 如果成功則 =return true=, 代表 =acquire(arg)= 已經成功可以退出了。 由於沒有競爭發生, 所以 wait queue 不需要 insert Node
** addWaiter(mode)
=addWaiter= 的職責是, 當 =tryAcquire(arg)= 失敗時, 代表當前的 =Thread= 必須被封裝到 =Node= 中, 並成為 wait queue 的 =tail=
我們明確一下 =addWaiter= 的職責:
1. =addWaiter= 是必成功的 CAS 操作, 執行完成後會 =return node=, 此時 =node= 就是 wait queue 的 =tail=
2. =addWaiter= 只負責將 =node= 加入 wait queue, 至於 =node= 處在 wait queue 中, 是要以 CAS 方式自旋, 還是以 park 的方式自旋, 這屬於 =acquireQueued= 的職責
另外, 還有兩個要點:
1. wait queue 有可能沒被初始化過, 需要先執行初始化
2. 對 =head= 和 =tail= 的操作, 必須是 CAS 操作

=addWaiter=:
#+begin_src java
    /**
     * Creates and enqueues node for current thread and given mode.
     *
     * @param mode Node.EXCLUSIVE for exclusive, Node.SHARED for shared
     * @return the new node
     */
    private Node addWaiter(Node mode) {
        Node node = new Node(Thread.currentThread(), mode);
        // Try the fast path of enq; backup to full enq on failure
        Node pred = tail;
        if (pred != null) {
            node.prev = pred;
            if (compareAndSetTail(pred, node)) {
                pred.next = node;
                return node;
            }
        }
        enq(node);
        return node;
    }

#+end_src
=addWaiter= 的邏輯如下:
1. 首先將要進入 wait queue 的 =Node= 準備好
   準備一個 =Node= =node=, 將當前 =Thread= 封裝到 =node= 中, 作為準備成為 wait queue 的 =tail= 的 =node=
2. 確認 wait queue 是否存在: 檢查 =head= 是否需要被初始化
   * 先確定檢查的邏輯是否正確: =head= 和 =tail=, 要麼同時為 =null=, 要麼同時不為 =null=, 所以檢查 =pred= 等於檢查 =tail=, 也等於檢查 =head=
   * 如果 =head= 需要被初始化, 則直接交給 =enq(node)= 執行初始化
3. 如果 wait queue 存在, 將 =node= 替換成 =tail=
   * 對 =tail= 嘗試一次 CAS 操作以替換 =tail=, 如果成功, =return node= (也就是 =tail=)
   * CAS 操作失敗, 說明有其他 =node= 也在嘗試 CAS 替換 =tail=, 此時將 =addWaiter= 的職責移交給 =enq(node)=

注意, =addWaiter= 的邏輯理論就是要完成雙向的 =LinkedList= 的 =insert=:
1. 在確認 =wait queue= 存在後, 將 =node.prev= 指向 =tail=
2. 以 CAS 操作, 將 =node= 替換成 =tail=, 在 CAS 操作成功的前提下, 將 =pred.next= 指向 =node=
這兩步就是 =addWaiter= 中的兩個 =if= 判斷, 如果都成功完成, 就可以直接 =return node= 並離開 =addWaiter=; 如果其中一步失敗, 都需要將 =addWaiter= 的職責移交給 =enq(node)=
*** enq(node)
=enq(node)= 的職責是, 在 =addWaiter= 直接將 =node= =insert= 進 =wait queue= 中失敗時, 接管 =addWaiter= 的職責, 以 CAS 的方式 =insert= =node= 直到成功為止, 是必成功的 CAS 自旋函數。
會進入 =enq= 函數有兩種可能:
1. wait queue 不存在
   注意, 此時 =node.prev= 指向 =null=, 但 =node.prev= 應該指向 =head=, 且 =head.next= 應該指向 =node=
2. wait queue 存在, 但有其他 =Node= 也在嘗試 =insert= 而發生競爭導致
   注意, 此時 =node.prev= 已經指向的是一個過期的 =tail=, 並且當前的 =tail.next= 也沒有指向 =node=

簡單來說, =enq= 要做的事情就是確保 =node.prev= 和 =tail.next= 都指向正確的 =Node=

我們先考慮第二種情況, 也就是 wait queue 已經存在的情況, 處理邏輯是: 以 CAS 自旋的方式將 =node.prev= 指向正確的 =Node=, 並將 =Node.next= 指向自身:
1. 每次進入 while loop 時, 獲取 =tail= 的最新狀態
2. 先將 =node.prev= 指向最新的 =tail=
3. 以 CAS 的方式嘗試將 =tail= 替換成 =node=
4. 如果 CAS 操作成功, 則在 CAS 的保護下將 =tail.next= 指向 =node= 並離開; 如果失敗進入下一輪 while loop 重試

而針對第一種情況, 就是先初始化 wait queue:
1. 以 CAS 的方式 create =head=
2. 在 CAS 的保護下, 將 =tail= 指向 =head=
3. 最後, 離開此 while loop, =node= 在下一次循環嘗試 =insert=, 進入情況二
#+begin_src java
    /**
     * Inserts node into queue, initializing if necessary. See picture above.
     * @param node the node to insert
     * @return node's predecessor
     */
    private Node enq(final Node node) {
        for (;;) {
            Node t = tail;
            if (t == null) { // Must initialize
                if (compareAndSetHead(new Node()))
                    tail = head;
            } else {
                node.prev = t;
                if (compareAndSetTail(t, node)) {
                    t.next = node;
                    return t;
                }
            }
        }
    }

#+end_src
注意 =enq(node)= 的 =return= 是最新、剛剛過期的 =tail=, 也就是 =node.prev=:
 * 當 =compareAndSetTail(t, node)= 成功時, 是將 =tail= 替換成 =node=, 而此時 =t= 依然指向的是過期的 =tail=
 * 注意 =addWaiter= 調用 =enq(node)= 時, 沒有以任何 variable 接收 =enq(node)= 的 =return=
** acquireQueued(node, arg)
=acquireQueued= 是一種自旋, 是 =node= 進入 wait queue 後, 真正進入 *等待* 的函數。 這個 *等待* 有兩種, 一種是以 CAS 自旋, 一種是 park 自旋。 =acquireQueued(node, arg)= 被執行後, 線程就會陷入其中一種自旋策略, 沒有意外的話這個自旋會一直持續下去, 除非 =acquireQueued= 過程中發生異常中止 =acquireQueued= 才會 =return false=, 交給最後的 =selfInterrupt()=
 * 以 CAS 的方式在 wait queue 中自旋
   #+begin_src java
       final boolean acquireQueued(final Node node, int arg) {
       //     boolean failed = true;
       //     try {
               boolean interrupted = false;
               for (;;) {
                   final Node p = node.predecessor();
                   if (p == head && tryAcquire(arg)) {
                       setHead(node);
                       p.next = null; // help GC
                       failed = false;
                       return interrupted;
                   }
       //             if (shouldParkAfterFailedAcquire(p, node) &&
       //                 parkAndCheckInterrupt())
       //                 interrupted = true;
               }
       //     } finally {
       //         if (failed)
       //             cancelAcquire(node);
       //     }
       }
   #+end_src
   當 =p == head= 成立時, 會立刻觸發 =tryAcquire(arg)=, 如果 =tryAcquire(arg)= 失敗, 會重新進入 while loop, 直到成功為止, 這就是以 CAS 的方式在 wait queue 中自旋。 當 =tryAcquire(arg)= 成功, 代表這個在 =acquire(arg)= 中本因 =!tryAcquire(arg)= 失敗而進入 wait queue 的 =node=, 在這裡又透過 =acquireQueued= 的 while loop 調用了 =tryAcquire(arg)= 自旋成功。 這種自旋成功只會發生在 =node.pred = head= 的情況, 成功時也代表 =acquire(arg)= 成功了, 但與第一次 =!tryAcquire(arg)= 就成功的區別是, 此時 =node= 已經被加入 wait queue 並處在 =head.next=, 需要將 =node= 移出, 這個過程如下:
   1. 將當前 =node= 設置為 =head=
   2. 將過期的 =head.prev= 和 =head.next= 都指向 =null=
   3. 將 =failed= 設置為 =false=, 表示 =acquire(arg)= 成功
   4. 離開 =acquireQueued=, 並 =return interrupted=, 將響應 interrupt 的職責交給外層的 =if=

   將當前 =node= 設置為 =head= 的方法為 =setHead(node)=:
   #+begin_src java
       private void setHead(Node node) {
           head = node;
           node.thread = null;
           node.prev = null;
       }
   #+end_src
   首先要注意 =setHead= 被調用的位置是被 =tryAcquire= 保護的, 因此這個 =setHead= 是線程安全的; 其次, 注意其實現是將 =head= 設置為 =node= 後, 將 =thread= 和 =prev= 都設置為 =null=, 這說明 =head= 其實是一個 dummy node, 只用於讓 =head.next= 以 CAS 方式在 wait queue 中等待。

 * 以 park 的方式在 wait queue 中等待
   再次強調, =acquireQueued= 是一種自旋。 如果進入 park 而被阻塞, 被 unpark 後會重入 =acquireQueued= 的 while loop, 透過判斷 =node= 是否處在 =head.next= 的位置來決定 =node= 在 wait queue 中的自旋策略。
   當 =p == head= 不成立時, =node= 就會以 park 的方式在 wait queue 中自旋, 但不是瘋狂的 while 重試, 而是被 unpark 喚醒後再重試:
   #+begin_src java
       final boolean acquireQueued(final Node node, int arg) {
           boolean failed = true;
           try {
               boolean interrupted = false;
               for (;;) {
                   final Node p = node.predecessor();
                   // if (p == head && tryAcquire(arg)) {
                   //     setHead(node);
                   //     p.next = null; // help GC
                   //     failed = false;
                   //     return interrupted;
                   // }
                   if (shouldParkAfterFailedAcquire(p, node) &&
                       parkAndCheckInterrupt())
                       interrupted = true;
               }
           } finally {
               if (failed)
                   cancelAcquire(node);
           }
       }
   #+end_src
   在正式進入 park 前, 有兩件事情要做:
   1. 由於要進入 park, 因此要先告知 prev 自己需要被 unpark, 這部份由 =shouldParkAfterFailedAcquire(p, node)= 完成
      注意, 只有 *有資格* 發送 signal 的 =prev=, 才能 unpark 自己的 =next=, 所以 =shouldParkAfterFailedAcquire= 也負責找到 *有資格* 的 =prev=
   2. 告知 =prev= 後, 立刻進入 =park=, 這部份由 =parkAndCheckInterrupt()= 完成
*** shouldParkAfterFailedAcquire(p, node)
=shouldParkAfterFailedAcquire(p, node)= 有以下職責:
1. 確認 =prev= 是有效的 =Node=
   所謂有效的 =Node= 指的是 =waitStatus= 不能為 =CANCELED = 1=
2. 如果 =prev= 是無效的, 就順便將該 =prev= 移出 wait queue, 將 =prev= 指向更前面的 =prev=, 重複這個過程直到找到有效的 =prev= 為止
#+begin_src java
    /**
     * Checks and updates status for a node that failed to acquire.
     * Returns true if thread should block. This is the main signal
     * control in all acquire loops.  Requires that pred == node.prev.
     *
     * @param pred node's predecessor holding status
     * @param node the node
     * @return {@code true} if thread should block
     */
    private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
        int ws = pred.waitStatus;
        if (ws == Node.SIGNAL)
            /*
             * This node has already set status asking a release
             * to signal it, so it can safely park.
             */
            return true;
        if (ws > 0) {
            /*
             * Predecessor was cancelled. Skip over predecessors and
             * indicate retry.
             */
            do {
                node.prev = pred = pred.prev;
            } while (pred.waitStatus > 0);
            pred.next = node;
        } else {
            /*
             * waitStatus must be 0 or PROPAGATE.  Indicate that we
             * need a signal, but don't park yet.  Caller will need to
             * retry to make sure it cannot acquire before parking.
             */
            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
        }
        return false;
    }
#+end_src

*注意, 只有當 =pred.waitStatus = Node.SIGNAL= 時, 才會正常 =return true=, 並觸發 =&&= 後的 =parkAndCheckInterrupt=; 反之, 無論還做了什麼操作, 最後一定會 =return false= 不觸發 =&&= 後的 =parkAndCheckInterrupt=, 這樣設計是為了能夠在下一輪自旋重新做檢查。*

我們可以試想, 如果清除無效的 =prev= 後, =prev= 只剩下 =head= 這種情況: 由於, =head.next= 必不 park, 所以 =return false= 觸發下一輪 =acquireQueued= 採 CAS 自旋。

另外, 只有在兩種條件都滿足的情況下 =ws= 可以為 =PROPAGATE = -3=:
1. =prev = head=
2. =prev= 處於 =SHARED= mode, 也就是 =prev.nextWaiter = SHARED=
這種情況我們在 =SHARED= mode 的篇幅討論。
*** parkAndCheckInterrupt()
=parkAndCheckInterrupt()= 被調用的時機非常重要:
1. 由於在 =&&= 被調用, 因此只有在 =shouldParkAfterFailedAcquire(prev, node)= =return true=, =parkAndCheckInterrupt()= 才會被執行
2. =parkAndCheckInterrupt()= 被執行後, 線程就會立刻進入 park, 被 unpark 時先檢查在 park 時是否有收到 interrupt, 如果有則將 =interrupted= 設為 =true=, 直接進入下一輪 =acquireQueued= 自旋, 完成 interrupt 的響應推遲
#+begin_src java
    final boolean acquireQueued(final Node node, int arg) {
        // boolean failed = true;
        // try {
            boolean interrupted = false;
            for (;;) {
                final Node p = node.predecessor();
                if (p == head && tryAcquire(arg)) {
                    setHead(node);
                    p.next = null; // help GC
                    failed = false;
                    return interrupted;
                }
                if (shouldParkAfterFailedAcquire(p, node) &&
                    parkAndCheckInterrupt())
                    interrupted = true;
            }
        // } finally {
        //     if (failed)
        //         cancelAcquire(node);
        // }
    }
#+end_src
也就是說, 處在 park 自旋時, 即便收到 interrupt 而被喚醒, 也不立即響應 interrupt, 只有當 =prev = head= 時, 且透過成功的 =acquireQueued= CAS 自旋後 =return interrupted= 狀態, 將響應中斷的職責交給 =acquire(arg)= 中的 =selfInterrupt()=
#+begin_src java
    private final boolean parkAndCheckInterrupt() {
        LockSupport.park(this);
        return Thread.interrupted();
    }
#+end_src

注意, =parkAndCheckInterrupt()= 中是透過 =Thread.interrupted()= 來 =return interrupted= 狀態, 這樣做會導致 =thread= 的 =interrupted status= 被重設:
#+begin_src java
    /**
     * Tests whether the current thread has been interrupted.  The
     * <i>interrupted status</i> of the thread is cleared by this method.  In
     * other words, if this method were to be called twice in succession, the
     * second call would return false (unless the current thread were
     * interrupted again, after the first call had cleared its interrupted
     * status and before the second call had examined it).
     *
     * <p>A thread interruption ignored because a thread was not alive
     * at the time of the interrupt will be reflected by this method
     * returning false.
     *
     * @return  <code>true</code> if the current thread has been interrupted;
     *          <code>false</code> otherwise.
     * @see #isInterrupted()
     * @revised 6.0
     */
    public static boolean interrupted() {
        return currentThread().isInterrupted(true);
    }
#+end_src
注意 doc 的部份: /Tests whether the current thread has been interrupted.  The interrupted status of the thread is cleared by this method./  也就是說, 如果在 park 期間即便有收到 interrupt, 調用 =Thread.interrupted()= 後 thread 的 =interrupted status= 會被重設。 這也是 =acquire(arg)= 最後要響應 interrupt 時, 要自己 interrupt 自己的原因。
** selfInterrupt()
我們回到最外層的 =acquire(arg)=:
#+begin_src java
    /**
     * Acquires in exclusive mode, ignoring interrupts.  Implemented
     * by invoking at least once {@link #tryAcquire},
     * returning on success.  Otherwise the thread is queued, possibly
     * repeatedly blocking and unblocking, invoking {@link
     * #tryAcquire} until success.  This method can be used
     * to implement method {@link Lock#lock}.
     *
     * @param arg the acquire argument.  This value is conveyed to
     *        {@link #tryAcquire} but is otherwise uninterpreted and
     *        can represent anything you like.
     */
    public final void acquire(int arg) {
        if (!tryAcquire(arg) &&
            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
            selfInterrupt();
    }
#+end_src
這裡要在次強調, =acquire= 不響應 interrupt 是指在 wait queue park 的線程如果收到 interrupt, 被 unpark 後不會立刻響應中斷, 而是透過 =interrupted = true= 來紀錄被中斷後進入下一輪 =acquireQueued= 自旋, 如果 =p == head= 不成立, 該線程會繼續 park 自旋; 也就是只要 =node= 沒有來到 =head.next=, 都不會響應 interrupt; 直到當 =p == head= 成立時, 透過成功的 =acquireQueued= CAS 自旋 =return interrupted= 狀態, 將響應中斷的職責交給 =acquire(arg)= 中的 =selfInterrupt()=

而 =selfInterrupt()= 執行的自己 interrupt 自己:
#+begin_src java
    /**
     * Convenience method to interrupt current thread.
     */
    static void selfInterrupt() {
        Thread.currentThread().interrupt();
    }
#+end_src
這樣做相當於將 interrupt 推遲到此時響應, 此時 =thread= 才能去執行 =catch (InterruptedException) {...}=
* acquireInterruptibly(int arg)
/ongoing.../
* tryAcquireNanos(int arg, long nanosTimeout)
/ongoing.../
