#+TITLE: 可見性問題
可見性問題的源頭在於, 引入了多級 cache 緩存結構的設計, 使得不同 CPU 之間同時工作時數據發生不一致的問題。
一個線程對共享變量的修改, 另一個線程能立刻得到該變量最新的值, 我們稱該共享變量具備內存可見性。 談到內存可見性, 我們要先引出 Java Memory Model (JMM), JMM 規定所有的共享變量放在共享內存中, 當線程操作共享變量時, 將共享變量從共享內存中複製到自己的工作空間中, 然後對公共空間的變量副本操作, 操作完成後將數據刷新到共享內存中。
如果有兩個線程同時對共享變量修改, 就會引發可見性問題:
1. 共享變量 x = 0
2. T1, T2 從共享空間中取 x, 複製到自己的工作空間中, x = 0
3. T1, T2 分別執行 +1 操作, x = 1
4. T1, T2 分別將 x 刷新到共享空間中, x = 1

* CPU 多級緩存結構
由於 CPU 的運算速度比主內存 (物理內存) 的存去速度快很多, 為了提高存取速度, CPU 不直接與主內存通信, 而是在 CPU 和 主內存之間增加多級 Cache 緩層。 越靠近 CPU 的緩存速度越快, 內存越小。 按照 *數據存取順序* 和 *與 CPU 內核結合的緊密程度*, CPU 的緩存有 L1 和 L2 緩存, 部份 CPU 還有 L3 緩存。 L3 在多核時代更為普遍, 容量更大、存取速度更慢, 能被在同一個 CPU 板上所有 CPU 核共享, L3 的共享機制使緩存命中率提昇到 95%。
[[./image/cpu-cache-structure.png]]

每一級緩存大小大概如下:
+-------+-------------+
| cache | capacity    |
+-------+-------------+
| L1    | 32 or 64 KB |
+-------+-------------+
| L2    | 256 KB      |
+-------+-------------+
| L3    | 12 MB       |
+-------+-------------+         

知名的 Java 專家, Martin 和 Mike 在 QCon presentation 上給出的在緩存未命中時的參考數據:
+----------------+------------+----------------------+
| unit           | CPU cycles | consumes nanoseconds |
+----------------+------------+----------------------+
| register       | 1          |                    - |
+----------------+------------+----------------------+
| L1             | 3~4        |                    1 |
+----------------+------------+----------------------+
| L2             | 10         |                    3 |
+----------------+------------+----------------------+
| L3             | 40~50      |                   15 |
+----------------+------------+----------------------+
| QPI            |            |                   20 |
+----------------+------------+----------------------+
| Primary memory |            |                60~80 |
+----------------+------------+----------------------+

CPU 採取多級高速緩存的設計存取數據有兩大好處:
1. 保證 CPU 指令運行時, 避免因為和主內存發生 I/O 的停頓
2. 以批處裡的方式, 合併對同一地址數據的多次讀寫, 減少對 QPS 的佔用
* Bus Lock and Cache Lock
為了解決內存可見性的問題, CPU 提供了兩種鎖: *Bus Lock 總線鎖* 和 *Cache Lock 緩存鎖*
 * Bus Lock
   Bus 負責了 CPU 與外界所有設備的通信, 包括高速緩存、內存、北橋, 其通過地址總線發送要訪問的部件, 透過數據總線實現雙向傳輸。
   每當緩存未命中時, CPU 內核需要向下級緩存或主內存存取, 此時 CPU core 會在總線上發出一個 LOCK# 信號來鎖住要訪問的設備, 阻塞其他 CPU core 對該設備的操作。
 * Cache Lock
   Bus Lock 的缺陷是顆粒度太大, 更好的方式是降低保護的顆粒度, 這就是緩存鎖。 緩存鎖不直接阻塞整個設備, 只保證被多個 CPU 緩存間的數據是一致的就好, 這是透過規範要各個 CPU core 訪問緩存設備時都遵循一定的協議作到的, 這樣的協議稱為 *緩存一致性協議*, 常見的有 MSI, MESI, MOSI 等。 整體而言, 緩存一致性機制就是當 CPU core 對緩存中的數據進行操作時, 通知其他 CPU core 放棄存儲在其內部的緩存數據, 或是主動從內存中讀取。
