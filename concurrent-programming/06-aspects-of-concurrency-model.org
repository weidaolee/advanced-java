#+TITLE: 安全性、活躍度、性能
前幾個章節, 我們已經能夠讓程式併發地執行起來, 以後的章節我們會討論到各種各樣的併發模型, 每一個併發模型都能解決併發問題, 但是不同模型之間, 肯定有區別, 因此在本章我們要介紹衡量併發模型的三大重要方面, 也就是 *Safety 安全性*, *Activity 活躍度* 以及 *Performance 性能*
* Safety 安全性
我們經常聽到有人這麼說過: 這個方法是線程安全的, 那個類是線程不安全的等等。 而所謂的線程安全指的就是正確性, 也就是當程序併發執行起來時, 能按照我們期望的方式執行。 雖然 *不按照我們的期望* 是一個很大的範圍, 但是我們曾經歸納出, 三個併發問題的本源: cache 導致的可見性問題、任務切換導致的原子性問題、編譯器指令重排導致的有序性問題。 所謂線程安全, 也就是程序在這三個問題上得到保障。

那麼是否每一行代碼都要仔細任真的分析這三大問題是否都得到保障? 並不是, 其實只有在一種情況下需要: *存在共享數據, 且共享數據是會變化的。* 這是一個很顯然的想法, 好像是在說只要做的了數據本地化, 或是讓共享數據不變化, 那就做到了線程安全? 確實是, 並且一些技術方案是基於這個簡單的理論作到的, 比如 *線程本地存儲 Thread Local Storage (TLS)* 、 不變模式等等, 我們會在以後的章節介紹到。

在這裡, 我們先關注那些 *必須共享變化的數據* 的狀況。
** Data Race 數據競爭 與 Race Condition 競態
當多個線程會訪問同一個數據, 且至少有一個線程會修改這個數據, 那麼這裡就會存在安全性問題, 這種安全性問題有個術語叫做 *Data Race 數據競爭*, 比如:
#+begin_src java
class Count {
    private int count = 0;
    void add() {
        int i = 0;
        while (i ++ < 1000) {
            count += 1;
        }
    }
}
#+end_src
那麼我們對訪問數據的方法上鎖, 是否就能解決問題? 我們試著將訪問共享數據的方法都上鎖:
#+begin_src java
class Count {
    private int count = 0;

    synchronized int get () {
        return count;
    }

    synchronized void set (int v) {
        count = v;
    }

    void add() {
        int i = 0;
        while (i ++ < 1000) {
            set(get() + 1);
        }
    }
}
#+end_src
感覺好像很對, 但這是線程不安全的。啟動時, 兩個線程在不同的 CPU 上同時執行 get 方法可能都得到 0, 於是都寫入 1。 這種問題也有個術語叫做 *Race Condition 競態條件*, 它指的是 *程序的正確性依賴線程執行的順序。* 在這個案例中, set 的正確性依賴於 get 的結果。 我們再舉一個轉帳的例子, 比如轉帳時規定, 帳戶餘額必須大於轉出額度。 如果轉帳的代碼存在競態條件, 有可能發現超額轉出的問題, 比如 A 帳戶有 100, 兩個線程同時要從 A 帳戶轉走 100。

這類問題通常長這樣:
#+begin_src java
if (狀態變量滿足則執行條件) {
    操作...
}
#+end_src

*注意, synchronized 張開的臨界區只有方法體或 code block, 所以程序在切換方法時, 會脫離臨界區的保護, 也就是說, 將兩個分別是線程安全的方法組合使用時, 是線程不安全的, 存在原子性的問題。*
也就是說, 當我們需要將兩個線程安全的方法組合起來使用時, 需要用 *synchronized 張開一個臨界區, 把這些方法包進去*, *並且要注意是否共用頭一把鎖*, 否則是無效的。
以下這是一個錯誤示範:
#+begin_src java
void addIfNotExist(Vector v, Object o){
  if(!v.contains(o)) {
    v.add(o);
  }
}
#+end_src
Vector 的所有方法是線程安全的, 但是這樣寫是線程不安全的, 我們現在要正確的示範:
#+begin_src java
void addIfNotExist(Vector v, Object o){
    synchronized (v) {
        if(!v.contains(o)) {
            v.add(o);
        }
    }
}
#+end_src
這樣, contains, add, 以及我們自己定義的方法都是共用相同的鎖, synchronized 張開的臨界區保證了原子性, 方法調用間不切換線程。
* Activity 活躍度
所謂的活躍度問題, 就是只某個操作一直不能順利執行下去。 我們前面介紹了 *死鎖*, 它就是一種典型的活躍度問題, 除了死鎖之外還有兩種, *活鎖* 和 *飢餓*。
** 活鎖
所謂 *死鎖*, 是兩個線程佔用了彼此需要的資源, 又在等待對方釋放自己需要的資源, 而 *活鎖* 則相反, 兩個線程互相謙讓, 導致彼此都無法順利執行。
解決 *活鎖* 可以在謙讓時等待一個隨機的時間, 這樣兩個線程相撞的機會就很低了。 這個想法很簡單, 但是向 Raft 算法也使用了這種辦法。
** 飢餓
而 *飢餓*, 是有一個線程一直在等待自己需要的資源, 但是一直等不到。 在優先級極度不均勻且 CPU 繁忙時, 或是持有鎖的時間過長時, 就會出現 *飢餓* 的問題。
解決 *飢餓* 的思路有三種:
1. 保證資源充足
2. 公平調度
3. 避免持有鎖的時間過長
實際上, 1 和 3 就算沒有出現飢餓問題, 也是要盡力優化的, 所以真正能夠解決飢餓的問題, 是透過 *公平調度* 。我們在後面的章節會使用 *公平鎖* 來作到公平調度。
* Performance 性能
** 併發帶來的性能提昇的理論上限: Amdahl's Law
我們之所以此用併發技術, 是為了透過提高線程數量來提高吞吐能力, 但是對於共享的可變資源, 我們透過 *互斥鎖* 來保護, 但如果使用過度會導致串行化的範圍過大, 因此我們追求串行化的範圍越小越好。 現在我們介紹一種衡量程式 的 併發度的方式: *Amdahl's Law*, *它用於計算一個程式的併發度的理論上限*:

$$\frac{1}{(1 - p) + p / n}$$

其中, p 為串行化的比率, 1 - p 為並行化的比例, n 為 thread 的數量。 當 n 為無窮大時, *Amdahl's Law* 為:

$$\frac{1}{1 - p}$$

如果一個程序的串行化比例只有 5%, 那透過併發帶來的性能提昇的理論上限為 20 倍。

** 提昇性能的思路
 * 無鎖的解決方案
   如果使用鎖會導致串行化, 那麼不使用鎖, 就不會有串行化問題。 這類方案有: Local Thread Storage 線程本地存儲 (TLS), Copy-On-Write 寫入時複製, 樂觀鎖等, Java concurrent 包的 原子類, Disruptor 無鎖隊列等等。
 * 減少鎖匙有的時間
   這類方案有 ConcurrentHashMap, 它使用了分段鎖技術; 讀寫鎖, 也就是讀無鎖, 寫才上鎖等。
** 其他性能指標
 * Through 吞吐量
   單位時間內處裡的線程數量
 * Latency 延遲
   客戶端發出請求, 到收到響應的時間
 * 併發度
   能夠同時處裡的線程數量
