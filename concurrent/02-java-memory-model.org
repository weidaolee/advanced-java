#+TITLE: Java 內存模型
前面我們討論了併發編程所有問題題的三大本源: cache 帶來的可見性問題、任務切換帶來的原子性問題、編譯優化帶來的有序性問題。 而 Java 內存模型首先就著手解決了可見性與編譯優化的問題。
我們知道, 可見性是 cache 造成的, 有序性是編譯優化造成的, Java 內存模型提供了規範 JVM 按需限制使用 cache, 以及按需編譯優化的方法, 這些方法包括 *volatile* 、 *synchronized* 、 *final* 以及 *Happens-Before* 規則。 volatile 與 final 約束了 cache 的使用時機, Happens-Before 的中心思想是, 前一個操作對後續的操作是可見的。嚴格來說, 它約束了 compiler 的優化行為。
* volatile 與 final
 * volatile 關鍵字借鑒自 C, 其功能是宣告該變量的存取不可以透過 cache, 必須從共享內存中存取。
 * final 與 volatile 相反, 一個引用被宣告成 final 後由於不變性, JVM 會盡可能的優化, 包含使用 cache 與指令重排
* Happens-Before 規則
1. 順序性規則
   在一個線程中, 前面的操作 happens-before 於後續的任意操作
2. volatile 的規則
   一個 volatile 變量的寫操作, happens-before 於 volatile 的讀操作
3. 遞移性規則
   A happens-before B, 且 B happens-before C, 則 A happens-before C
4. synchronized 的規則
   synchronized 的釋放鎖 happens-before synchronized 的上鎖
5. 線程 start() 的規則
   A 是主線程, 啟動子線程 B, 則 A 在 start 前的操作 happens-before B 的任意操作
6. 線程 join() 的規則
   A 是主線程, join 子線程 B, 則 B 的操作 happens-before join 的操作
** 順序性, volatile 與 遞移性
考慮以下代碼:
#+begin_src java
class VolatileExample {
    int x = 0;
    volatile boolean v = false;
    public void write() {
        x = 1;
        v = true;
    }
    public void read() {
        if (v == true) {
            // x == ?
        }
    }
}
#+end_src
1. 根據 *順序性規則*, x = 1 happens-before v = true
2. 根據 *volatile 的規則*, v = true happens-before v == true
3. 根據 *遞移性規則*, x = 1
