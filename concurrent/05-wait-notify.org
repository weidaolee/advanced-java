#+TITLE: Wait-Notify 機制
在上一章我們討論 3 種避免 deadlock 的方法, 分別是 1. 一次性申請所有資源, 2. 主動放棄資源, 3. 按序申請資源。 我們也透過分析得到, 一次申請所有資源的代價很高, 主要是因為會被阻塞在 while 循環中, CPU 會浪廢在沒意義的條件判斷上。 這樣的問題我們當然可以使用簡單的 timeout 機制來解決, 但是我們在這裡要介紹一種更高級的機制, 這個機制可以透過一個現實案例來理解
* 完美的就醫流程
假設患者就診時, 醫師評估後需要先做檢查, 才能繼續診斷, 那麼最理想的流程應該是這樣的:
1. 患者先掛號, 然後去門診報到, 等待叫號
2. 門診叫號, 患者第一次見到醫生
3. 醫師判斷患者需要做檢查, 叫患者去檢查, 直接處裡下一位病患
4. 患者做完檢查, 重新向門診報到, 等待叫號
5. 門診叫號, 患者第二次見到醫生
現在我們將這個機制重新 model 成一個併發處裡的問題:
1. 門診資源是互斥的, 患者報到相當於申請鎖
2. 患者被叫號, 相當於獲得上鎖權
3. 醫生要求患者去做檢查, 相當於患者沒有滿足上鎖的所有條件
4. 患者去做檢查, 釋放門診資源
5. 患者做完檢查, 相當於滿足上鎖的條件

在只使用 while 的方式, 相當於每個病患不管自己的病號有沒有被叫到, 都瘋狂的問門診的護理師輪到自己了沒有, 而病患等待叫號的機制, 相當於由門診維持一個病號隊列, 規定病患必須依照叫號機制來就診, 這就是 Wait-Notify 機制。
* 簡單的 Wait-Notify 機制
在 Java 中, Wait-Notify 機制有多種實現方式, 最簡單的一種是透過 synchronized 和 wait(), notify(), notifyAll() 來實現。
** 等待隊列與互斥鎖
當門診叫號時, 有一個病患進入診間, 此時其他的病患就會進入等待, 也就是此時其他的病患正在一個 *等待隊列* 中, *這個等待隊列和互斥鎖是一對一的關係, 一個互斥鎖對應一個唯一的等待隊列。* 這其實就相當於, 一個鎖相當於一個門診資源, 病患可以同時掛好幾種門診, 而診間相當於臨界區, 同時間只允許一個病人進入診間。 在我們剛才提到的就診案例中, 醫生認為病患必須去做其他檢查, 也就是病患已經進入診間, 但是由於條件不滿足, 要求病患離開診間, 此時病患會進入 *等待*, *並釋放互斥鎖*:
[[https://static001.geekbang.org/resource/image/c6/d0/c6640129fde927be8882ca90981613d0.png]]
** 通知與重新申請資源
當門診叫號時, 就相當於透過 notify() 或 notifyAll() 通知並取得等待隊列中的線程。 被 notify() 或 notifyAll() 通知的線程只代表 *條件在通知當下是滿足的*, 因為有可能有一些情況會發生已經滿足的條件失效的情形, 此時又必須進入等待隊列, 比如有緊急病患插隊, 這點要格外注意。

另外, 被通知過的線程如果要重新執行, 必須再重新申請互斥鎖。 這相當於離開診間的患者, 無論他是去做什麼, 都要向診間重新報到。

*注意, 圖中有兩個隊列, 一個是完全沒有獲得過鎖的隊列, 另一個是獲得過鎖但是進入等待的隊列, notify 和 notifyAll 只會通知獲得過鎖的隊列, 而被重新喚醒的線程, 都是曾經進入診間的線程, 他們會接著從 wait() 之後的代碼繼執行, 這點很重要。*
[[https://static001.geekbang.org/resource/image/1b/8c/1b3e999c300166a84f2e8cc7a4b8f78c.png]]
** 等待與通知對象
再次強調 wait(), notify(), notifyAll() 操作的對象是互斥鎖對應的等待隊列, 如果 synchronized 的對象是 this, 則操作的是 this.wait(), this.notify(), this.notifyAll(), synchronized 的對象是 target, 則操作的是 target.wait(), target.notify(), target.notifyAll()。

並且, 一個對象能夠操控 wait(), notify(), notifyAll() 的前是, 它已經獲得鎖, 也就是它已經進入臨界區中。 這點很容易被忽視, 比如 synchronized 的對象是 this, 但是在 咧界區操作的是 target.wait(), 這是錯誤的. JVM 會拋出 runtime exception: java.lang.IllegalMonitorStateException
* 用 Notify-Wait 機制來 model 一個解決死鎖的方案
首先, 我們要明確我們現在是要透過一次申請所有資源的方式解決死鎖資源, 因此一個全局唯一的 Allocator 的存在是必要的, 那麼無論用哪一種方式實現 Notify-Wait 機制, 都只要考慮以下 4 個問題:
1. 互斥鎖的對象是誰
2. 上鎖的必要條件
3. 進入等待的條件
4. 發出通知的條件
延續我們的案例:
1. 互斥鎖的對象:
   Allocator 的 instance
2. 上鎖滿足條件:
   轉入與轉出帳戶都沒有被申請過
3. 進入等待的條件:
   當線程不滿足上鎖的必要條件
4. 發出通知的條件:
   有線程釋放帳戶
接下來, 我們將會使用 Wait-Notify 機制的經典範式:
#+begin_src java
while (條件不滿足) {
    wait();
}
#+end_src
這兩行代碼, 是經典範式, 它解決一個很重要的問題, 也就是一個滿足上鎖條件的線程, 有可能因為某些原因而又不滿足上鎖條件, 必須重新檢查條件是否被滿足。 注意, 這種範式是用來遵守的. 不是用來打破的, 在後面的章節我們會再詳細討論。 接下來, 我們來實現我們的案例:
#+begin_src java
class Allocator {
    private static List<Object> lockedResources = new ArrayList<>();
    private static instance = new Allocator();
    private Allocator();
    public Allocator getInstance() {
        return instance;
    }

    synchronized void apply (Object from, Object to) {
        while (lockedResources.contains(from) || lockedResources.contains(to)) {
            try {
                wait();
            } catch (Exception e) {
                //...
            }
        }
        lockedResources.add(from);
        lockedResources.add(to);
    }

    synchronized void free(Object from, Object to) {
        lockedResources.remove(from);
        lockedResources.remoce(to);
        notifyAll();
    }
}
#+end_src
* prefer notifyAll rather than notify
notify 和 notifyAll 的區別在 notify 只會隨機通知 1 個線程, 而 notifyAll 會通知所有線程。 感覺 notify 更好一些, 因為只有一個線程會進行競爭, 但這有可能導致有些線程永遠不被通知道。
我們考慮以下案例, 假設我們有 4 個帳戶, A1-A4, 和 4 個線程 T1-T4:
1. T1 申請 A1、A2, 上鎖成功
2. T2 申請 A3、A4, 上鎖成功
3. T3 申請 A1、A2, 進入等待
4. T4 申請 A3、A4, 進入等待
5. T1 釋放 A1、A2, 歸還資源
此時如果使用 notify, 有可能通知的是 T4, 但是 T4 需要的資源並沒有被釋放, 因此 T4 會進入等待, T2 如果釋放了 A3、A4, 它會通知 T3 或 T4, 那麼至少有一個在等待的線程會永遠處在等待的狀態。
* wait 和 sleep
這兩個方法經常被對比, 首先注意, 兩個方法都不會佔用 CPU 資源
 * wait()
   wait() 方法是屬於 Object 類的方法, 它操作的對象是等待隊列。 調用 wait 後會釋放鎖, 是 Wait-Notify 不可少的機制, 並且它只在臨界區可以被調用。
 * sleep()
   sleep() 方法是屬於 Thread 類的方法, 它操作的對象是線程本身。 調用 sleep 必須指定時間, 調用它也不會釋放鎖. 但是合理地使用它可以讓出競爭鎖的機會, 並且它可以在任意地方被調用。
