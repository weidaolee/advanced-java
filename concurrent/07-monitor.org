#+TITLE: Monitor 管程
隨著計算機性能的發展, 併發技術也開始變複雜起來, 那麼有沒有一種核心技術能讓我們方便的處裡併發問題呢? 當然有, 而如果在這些技術中只能挑選一種來介紹, 我一定會挑選 *Monitor 管程* 。在剛接觸 Java 時, 我以為 Java 會選擇信號量這個技術來解決併發問題, 因為 OS 的課程告訴我們, 信號量能解決一切併發問題, 但其實 *管程和信號量是等價的, 他們之間可以互相實現。* 而 *管程* 用起來比信號量簡單, 所以 Java 選擇了管程。

所謂 *管程, 指的是管理共享變量以及對共享變量操作的過程, 使它能支持併發*, 翻譯成 Java 則是: *管理類的成員變量和成員方法, 使這個類是線程安全的。* 而具體怎麼管呢?

歷史上曾經出現三種管程模型, 分別是: Hasen、Hoare 和 MSEA 模型, 其中現在廣泛應用的是 MSEA 模型, 並且 Java 實現參考的也是 MSEA 模型, 接下來我們仔細介紹 MSEA 模型。
* MSEA
在控制併發程序, 主要就是協調兩件事情, 第一是 *互斥*, 即同一時刻只允許一個線程操作共享資源; 第二是 *同步*, 即線程之間的通信、協作, 我們分別看看如何協調 *互斥* 。
** 互斥
管程解決互斥問題的思路非常簡單, 既然讓線程直接訪問互斥的共享資源是不安全的, 那麼就將共享資源與操作共享資源的方法都封裝起來, 對外只暴露安全的方法。 比如, 我們想要實現一個線程安全的阻塞隊列, 那麼我們就把線程不安全的隊列、add()、 poll() 都封裝起來, 對外暴露線程安全的方法。 利用管程, 可以快速實現這樣的方法, 請看下圖:
[[https://static001.geekbang.org/resource/image/59/c4/592e33c4339c443728cdf82ab3d318c4.png]]
假設我們的變量 X 是一個互斥的共享資源, 在併發模式下管程會將 X 和操作 X 的方法封裝起來, 線程要調用這些方法, 必須透過管程鎖提供的線程安源的操作。 你會發現, 管程是透過 *封裝* 以及 *重載* 來作到這件事情, 它正是在利用 OOP 技術來解決這個問題。
** 同步
協調同步稍微有點複雜, 下圖我們展示 MSEA 管程模型的示意圖:
[[https://static001.geekbang.org/resource/image/83/65/839377608f47e7b3b9c79b8fad144065.png]]

*** 入口 和 阻塞隊列
在管程模型裡, 共享變量和共享變量的操作是被封裝起來的, 圖中最外層的框就是帶表封裝的含意。 *框的上側有一個入口, 入口有一個入口等待隊列, 當多個線程試圖進入管程內部時, 只有一個線程會成功進入, 其他線程必須在入口隊列內等待。* 這個入口的等待隊列, 我們稱為 *阻塞隊列* 。
*** 條件變量 和 條件變量等待隊列
*在一個管程中條件變量可以有多個, 每一個條件變量對應一個等待隊列。* 接下來我們演示一下管程如何同步(通知)線程。 線程 T1 先進入管程會先嘗試執行阻塞隊列的 poll() 操作, 但是要能執行阻塞隊列的 poll(), 前提是阻塞隊列是非空的, 那麼此時 *阻塞隊列非空* 就是一個 *條件變量*, 因為現在條件變量沒有滿足, 所以 T1 會進入 *阻塞對類非空* 的等待隊列中。

此時, T2 線程對管程的阻塞隊列進行 add() 操作, 那麼條件變量 *阻塞隊列非空* 被滿足了, T2 要通知 T1, 於是 T1 會從等待隊列裡出來, 但是會回到阻塞隊列中等待。

假設條件變量是 A, 則線程 T1 不滿足 A 時, T1 會操作 A.wait(), 而線程 T2 執行時告知 T1 條件 A 滿足, 則是調用 A.notify() 或是 A.notifyAll()
* wait() 的正確姿勢
在前面的章節我們有提到 wait() 的經典範式:
#+begin_src java
while (條件不滿足) {
    wait();
}
#+end_src
這與 Java 的管程實現參考了 MSEA 有關。Hasen、Hoare 和 MSEA 模型核心區別就在於, 當條件變量滿足後, 如何通知相關的線程:
 * Hasen
   Hasen 模型要求, notify 必須是最後一行, 這樣 T2 通知 T1 後, T2 就結束了, 然後 T1 就可以執行, 這樣就保證了只有一個線程在操作。
 * Hoare
   Hoare 模型是, T2 通知完 T1 後, T2 會阻塞, T1 先執行, T1 執行完後會喚醒通知它的線程, 也就是 T2。 但是 Hoare 會比 Hasen 多一次阻塞-喚醒的操作。
 * MSEA
   我們發現, Hasen 的好處是沒有多餘阻塞-喚醒的操作, 但是限制了編程的行為, 因為 notify 必須被放在最後; Hoare 的好處是 notify 不用被放在最後, 但是會有多餘的阻塞-喚醒操作。 MSEA 想要作到的是, 兩者的好處全都要, 並且沒有副作用。 所以當 T2 通知完 T1 後, T2 會繼續執行, T1 只是回到入口的阻塞隊列, 之所以要回到入口的阻塞隊列, 是因為滿足的條件有可能失效了, 這就是為什麼經典範式要求一開始要把 wait() 和條件寫在 while 裡面的原因。

* notify() 的使用時機
前面提到了, 使用 notify 的風險是可能造成有線程永遠不會執行, 這是一種 *活鎖* 問題。但是, 以下三個條件都滿足時, 可以使用 notify():
1. 所有線程擁有相同等待條件
2. 所有線程被喚醒後, 執行相同操作
3. 只需要喚醒一個線程

* wait() 的超時參數
其實我們會發現, MSEA 的方案並不是完全沒有副作用, 因為它有可能導致使用 notify 的風險是可能造成有線程永遠不會執行, 也就是有線成回到阻塞隊列中, 但是沒有線程通知它了, 所以 wait() 有一個超時參數, 避免永遠等待下去, Hansen 和 Hoare 並沒有超時等待參數, 因為這兩種方案都能保證所有線程一定會被執行。
