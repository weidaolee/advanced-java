#+TITLE: 不同的管程模型
我們已經在多個地方討論到 Monitor:
 * 在 *重量級鎖* 的部份, 我們知道 Java 為每個 Object 準備了一個 Monitor, 在那個單元我們討論了它的結構。
 * 在 *線程間通信* 的部份, 我們討論了當我們使用 Java 的 Wait-Notify 機制時, JVM 是如何和 Monitor 工作的。

歷史上曾經出現三種管程模型, 分別是: Hasen、Hoare 和 MSEA 模型, 其中現在廣泛應用的是 MSEA 模型, 並且 Java 實現參考的也是 MSEA 模型, 接下來我們仔細介紹 MSEA 模型。

* Monitor 模型
在控制併發程序, 主要就是協調兩件事情, 第一是 *互斥*, 即同一時刻只允許一個線程操作共享資源; 第二是 *同步*, 即線程之間的通信、協作, 我們分別看看如何協調 *互斥* 。
** 互斥
管程解決互斥問題的思路非常簡單, 既然讓線程直接訪問互斥的共享資源是不安全的, 那麼就將共享資源與操作共享資源的方法都封裝起來, 對外只暴露安全的方法。 比如, 我們想要實現一個線程安全的阻塞隊列, 那麼我們就把線程不安全的隊列、add()、 poll() 都封裝起來, 對外暴露線程安全的方法。 利用管程, 可以快速實現這樣的方法, 請看下圖:
[[https://static001.geekbang.org/resource/image/59/c4/592e33c4339c443728cdf82ab3d318c4.png]]
假設我們的變量 X 是一個互斥的共享資源, 在併發模式下管程會將 X 和操作 X 的方法封裝起來, 線程要調用這些方法, 必須透過管程鎖提供的線程安源的操作。 你會發現, 管程是透過 *封裝* 以及 *重載* 來作到這件事情, 它正是在利用 OOP 技術來解決這個問題。
** 同步
協調同步稍微有點複雜, 下圖我們展示 MSEA 管程模型的示意圖:
[[https://static001.geekbang.org/resource/image/83/65/839377608f47e7b3b9c79b8fad144065.png]]

這也是我們之前提到的, 調用 wait() 的線程是進入 WaitSet, 而不是直接進入 EntryList, 而是等到被 notify 時, 才會進入 EntryList。
* wait() 的正確姿勢
在前面的章節我們有提到 wait() 的經典範式:
#+begin_src java
while (條件不滿足) {
    wait();
}
#+end_src
這與 Java 的管程實現參考了 MSEA 有關。Hasen、Hoare 和 MSEA 模型核心區別就在於, 當條件變量滿足後, 如何通知相關的線程:
 * Hasen
   Hasen 模型要求, notify 必須是最後一行, 這樣 T2 通知 T1 後, T2 就結束了, 然後 T1 就可以執行, 這樣就保證了只有一個線程在操作。
 * Hoare
   Hoare 模型是, T2 通知完 T1 後, T2 會阻塞, T1 先執行, T1 執行完後會喚醒通知它的線程, 也就是 T2。 但是 Hoare 會比 Hasen 多一次阻塞-喚醒的操作。
 * MSEA
   我們發現, Hasen 的好處是沒有多餘阻塞-喚醒的操作, 但是限制了編程的行為, 因為 notify 必須被放在最後; Hoare 的好處是 notify 不用被放在最後, 但是會有多餘的阻塞-喚醒操作。 MSEA 想要作到的是, 兩者的好處全都要, 並且沒有副作用。 所以當 T2 通知完 T1 後, T2 會繼續執行, T1 只是回到入口的阻塞隊列, 之所以要回到入口的阻塞隊列, 是因為滿足的條件有可能失效了, 這就是為什麼經典範式要求一開始要把 wait() 和條件寫在 while 裡面的原因。

* notify() 的使用時機
前面提到了, 使用 notify 的風險是可能造成有線程永遠不會執行, 這是一種 *活鎖* 問題。但是, 以下三個條件都滿足時, 可以使用 notify():
1. 所有線程擁有相同的等待條件
2. 所有線程被喚醒後, 會執行相同操作
3. 只需要喚醒一個線程

* wait() 的超時參數
其實我們會發現, MSEA 的方案並不是完全沒有副作用, 因為它有可能導致使用 notify() 的風險是可能造成有線程永遠不會執行, 也就是有線程一直在 WaitSet 中 WAITING, 但是沒有線程通知它了, 所以 wait() 有一個超時參數, 避免永遠等待下去, Hansen 和 Hoare 並沒有超時等待參數, 因為這兩種方案都能保證所有線程一定會被執行。
