#+TITLE: AQS 基礎
AbstractQueuedsynchronizer 是用於構件 JUC 顯式鎖與同步容器的基礎類。 許多 JUC 顯示鎖都是基於 AQS 構建的, 比如: ReetrantLock, Semaphore, CountDownLatch, ReetrantReadWriteLock, FuterTask 等。 AQS 也是 JUC 顯式鎖用於確保在高併發場景的性能所採用的技術。

在高併發場景中有兩種行為會導致性能瓶頸:
 * 頻繁阻塞-喚醒會引發
   阻塞-喚醒會觸發進程的工作狀態在用戶態和內核態切換, 這個過程要傳遞大量的上下文訊息確保狀態切換後程序能正常執行, 解決的方案就是透過 CAS 自旋以不阻塞的方式替代阻塞-喚醒
 * 大量 CAS 空自旋
   由於 CAS 自旋操作不會阻塞 CPU, 大量的 CAS 空自旋會使 CPU 使用率飆升, 並且會因為 CAS 操作、緩存失效的通知等佔用大量 Bus 資源, 解決的方案就是以阻塞-喚醒替代 CAS 自旋

可以看見, 這兩種性能瓶頸是此消彼漲的, 因此在解決高併發的性能問題時, 就必須在這兩種技術之間 trade off。 解決的方式主要有兩種:
 * 分散熱點
   Atomic 類中的 Accumulator 類採用的技術方案就是分散熱點, 將修改行為做分散, 在讀取時同步所有的修改。 這種方案有兩個好處:
   1. 修改數據時不需讀取數據, 能避免為了確保可見性和有序性對性能的犧牲
   2. 修改數據的行為被分散, 減少大量的 CAS 空自旋
 * 隊列消峰
   隊列消峰是 JUC 顯式鎖用於確保併發性能最主要的技術方案: 透過引入隊列來建構在阻塞-喚醒與 CAS 自旋之間 trade off 的機制
* 隊列消峰緩解資源競爭
隊列消峰的技術理念是透過引入隊列來緩解無效的資源競爭, 比如:
 * CLH 自旋鎖
   透過引入隊列, 讓 N - 1 個線程以普通方式自旋, 只有隊列尾入隊列操作使用 CAS 自旋
   [[./image/CLH-queue.png]]
 * 引入等待隊列
   引入等待隊列來協調競爭, 讓處於等待隊列的線程處於阻塞狀態, 每次只喚醒隊列頭部的線程競爭資源
   [[./image/wait-queue.png]]
 * AQS 的內部隊列
   AQS 的內部隊列是 CLH 隊列的改進, 主要原理與 CLH 差不多:
   [[./image/AQS-queue.png]]
* AQS 的核心成員
AQS 基於 template pattern, 為鎖的申請與釋放、隊列的維護等操作提供一系列的 template methods, 並且為這些方法提供鉤子以應對多種 JUC 鎖與同步工具類。
** AQS 同步狀態 state
AQS 使用了 long 類型的 state 來表示 AQS 的同步狀態。 state 以 volatile 修飾, 根據 Happens-Before 規則第二條: volatile 變量的寫入 happens-before volatile 變量的讀取, 因此對 state 的存取具有可見性與有序性保障, 另外也提供了 CAS 的方式 set state。以下為 AQS 提供的用於存取 state 的方法:
#+begin_src java
    private volatile int state;

    protected final int getState() {
        return state;
    }

    protected final void setState(int newState) {
        state = newState;
    }

    protected final boolean compareAndSetState(int expect, int update) {
        // See below for intrinsics setup to support this
        return unsafe.compareAndSwapInt(this, stateOffset, expect, update);
    }
#+end_src

state 用於告知線程 AQS 目前處在哪一個狀態並做出相應的行為, 並且能在自旋次數未用完的前提下, 能使這些操作達到 CAS 自旋鎖的性能。 我們以 ReetrantLock 的重入為例:
1. state = 0 時註冊為 owner, 並將 state CAS 成 1
2. state != 0 時, 再次 CAS 確認, 如果失敗了進行身份驗證, 確認是否可重入
3. 如果可重入, update state, 此時不需要 CAS set state, 因為此時線程是相同的, 沒有原子性問題
4. 如果 CAS(0, 1) 失敗, 且身份驗證也失敗, 則代表自己不應該進入臨界區, 申請 lock 失敗

#+begin_src java
final boolean nonfairTryAcquire(int acquires) {
    final Thread current = Thread.currentThread();
    int c = getState();
    // 再次確認鎖是否被釋放
    if (c == 0) {
        if (compareAndSetState(0, acquires)) {
            // 如果狀態為 0 則相當於成功獲取鎖, 將自己註冊為 Owner
            setExclusiveOwnerThread(current);
            return true;
        }
    }
    // 如果 current = Owner, 說明可以重入
    else if (current == getExclusiveOwnerThread()) {
        // 可重入
        int nextc = c + acquires;
        if (nextc < 0) // overflow
            throw new Error("Maximum lock count exceeded");
        // 不必使用 CAS set state, 因為此時線程是相同的, 沒有原子性問題
        setState(nextc);
        return true;
    }
    // 說明 CAS(0, 1) 失敗, 並且自己不是 Owner, return fales
    return false;
}
#+end_src
該實現有以下幾點要注意
1. 進行二次確認時, 也有可能失敗並 return fales
2. setState() 和 CASsetState() 只差在有沒有保證原子性
   因為兩種方法操作的對象都是 volatile 的 state, 已經保證了可見性和有序性
3. 重入時可以使用 setState() 即可
   由於重入時線程是相同的, 所以不會有線程切換的問題, 因此也沒有有序性的問題
** Node
AQS 的內部隊列是以其內部靜態類 Node 組織起來的。
Node 有以下主要成員:
1. thread, prev Node 和 next Node
2. waitState, 用於標示自己處在哪一種狀態上等待
3. nextWaiter, 用於維護隊列與條件等待隊列
4. waiting mode, 用於標示 Node 是處在 shared 等待或 exclusive 等待
*** thread, prev, next
每個 Node 持有一個 Thread 對象, 並且有 prev 和 next 表示前後的 Node:
#+begin_src java
volatile Thread thread;

// 當前 Node 會在 prev 上進行普通自旋
volatile Node prev;

// next Node
volatile Node next;
#+end_src

*** waitState
waitState 用於標示自己處在哪一種狀態上等待, 這些等待狀態是 static 的常量:
#+begin_src java
volatile int waitStatus; // default to 0

/** waitStatus value to indicate thread has cancelled */
static final int CANCELLED =  1;

/** waitStatus value to indicate successor's thread needs unparking */
static final int SIGNAL    = -1;

/** waitStatus value to indicate thread is waiting on condition */
static final int CONDITION = -2;

/**
 * waitStatus value to indicate the next acquireShared should
 * unconditionally propagate
 */
static final int PROPAGATE = -3;
#+end_src
 * waitState = CANCELLED = 1
   這個狀態表示自己的 Thread 由於 timeout 或是被 interrupt, 要切換成 RUNNABLE 狀態做相應的處裡, 並且這種處裡是一種異常處裡, 是與臨界區無關的, 因此處於 CANCELLED 的 Node 不會參與資源競爭, 並且會一直維持這個狀態直到被釋放。
   /This node is cancelled due to timeout or interrupt. Nodes never leave this state. In particular, a thread with cancelled node never again blocks./

 * waitState = SIGNAL = -1
   這個狀態表示自己的 next Node 已經被 park, 當前 Node 被釋放時需要 unpark next Node。
 * waitState = CONDITION = -2
   AQS 的隊列有兩種, 一種是 synchronized 同步隊列, 另一種是由於等待某個 Condition 而處在阻塞的狀態的條件等待隊列。 這個狀態表示自己處在 Condition 等待隊列中被阻塞, 當持有鎖的線程調用了 Condition 的 signal() 時, 該 Node 會被轉移到同步隊列。
 * waitState = PROPAGATE = -3
   表示自己的下一個 Node 嘗試獲取共享鎖時, 共享狀態會被無條件傳播下去。 因為共享鎖的讀取是不互斥的, 因此當一個嘗試獲取共享鎖而被阻塞的 Node 被喚醒時, 也需要喚醒其他後續的 Node。

注意, waitState 處於初始化狀態時為 0, 而處於 CANCELLED 狀態時為 1; 當 waitState >= 0 的狀態都需要 signal 的參與。
*** nextWaiter
nextWaiter 有兩種情況會使用到:
1. 該 Node 處於一個條件等待隊列上, 這個 nextNode 指向下一個條件等待隊列中的下一個 Node
2. 該 Node 處於一個條件等待隊列上, 這個 nextNode 指向 SHARED

#+begin_src java
 /**
 * Link to next node waiting on condition, or the special
 * value SHARED.  Because condition queues are accessed only
 * when holding in exclusive mode, we just need a simple
 * linked queue to hold nodes while they are waiting on
 * conditions. They are then transferred to the queue to
 * re-acquire. And because conditions can only be exclusive,
 * we save a field by using special value to indicate shared
 * mode.
 */
 Node nextWaiter;
 #+end_src
*** waiting mode
 #+begin_src java
  /** Marker to indicate a node is waiting in shared mode */
  static final Node SHARED = new Node();
  /** Marker to indicate a node is waiting in exclusive mode */
  static final Node EXCLUSIVE = null;
 #+end_src

 #+begin_src java
 /**
  * Returns true if node is waiting in shared mode.
  */
 final boolean isShared() {
     return nextWaiter == SHARED;
 }
 #+end_src
*** constructor
Node 有三種 constructor overload 版本, 第一種用於創建 AQS wait queue 的 head 和 SHARED 標示:
#+begin_src java
 Node() {    // Used to establish initial head or SHARED marker
 }
#+end_src

第二種和第三種分別用於兩種情況:
1. 新的 Node 要阻塞在 AQS 的 wait queue
   nextWaiter 會被設為 mode, 如果 mode 是 EXCLUSIVE 則 nextWaiter = null; 如果 mode = SHARED 則為當初 SHARED initial 的 Node
   #+begin_src java
    Node(Thread thread, Node mode) {     // Used by addWaiter
        this.nextWaiter = mode;
        this.thread = thread;
    }
   #+end_src
2. 新的 Node 要阻塞在 Condition wait queue
   #+begin_src java
    Node(Thread thread, int waitStatus) { // Used by Condition
        this.waitStatus = waitStatus;
        this.thread = thread;
    }
   #+end_src
** FIFO 雙向同步隊列
AQS 的 wait queue 是 CLH queue 的改進, 當 Thread 申請 AQS 鎖失敗時, Thread 會被封裝到一個 Node 裡面, 通過 CAS 操作添加到 tail, 當有 Thread 釋放鎖時, 會嘗試從 head 申請鎖
#+begin_src java
/**
 * Head of the wait queue, lazily initialized.  Except for
 * initialization, it is modified only via method setHead.  Note:
 * If head exists, its waitStatus is guaranteed not to be
 * CANCELLED.
 */
private transient volatile Node head;

/**
 * Tail of the wait queue, lazily initialized.  Modified only via
 * method enq to add new wait node.
 */
private transient volatile Node tail;
#+end_src

head 和 tail 都是 lazy 的, 只有在發生競爭時且有線程要進入 AQS wait queue 時 head 才會被創建, 並且只有 setHead 可以操控 head:
#+begin_src java
/**
 * Sets head of queue to be node, thus dequeuing. Called only by
 * acquire methods.  Also nulls out unused fields for sake of GC
 * and to suppress unnecessary signals and traversals.
 *
 * @param node the node
 */
private void setHead(Node node) {
    head = node;
    node.thread = null;
    node.prev = null;
}
#+end_src
