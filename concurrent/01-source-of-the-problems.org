#+TITLE: 併發問題的源頭: 可見性, 原子性, 有序性
在 Von Neumann 體系結構中, 程序的運行主要依賴 CPU、內存和 I/O 設備, 而這種體系結構存在的核心問題是, 這三者之間的速度差異。 為了更合理釋放計算機的性能, 這些年工業界在計算機結構、作業系統、編譯程序都做出了貢獻, 這些貢獻體現為:
1. CPU 增加了 cache, 緩解 CPU 與內存的速度差異
2. OS 增加了進程、 線程, 以多路復用 CPU, 進而平衡 CPU 與 I/O 設備之間的速度差異
3. compiler 優化了指令執行的順序, 使得緩存可以被更合理的運用

CS 領域有一個定律是 *透過引入新技術解決技術的問題, 必帶來新的問題*, 在這裡這個定律是這樣體現的:
1. CPU 增加了 cache, 引入了可見性的問題
2. 分時復用/線程切換, 引入了原子性問題
3. compiler 的指令重排, 引入了有序性問題
以下, 我們將詳細討論每一種新問題是如何發生的。
* CPU 增加 cache 引入了可見性問題
** 可見性的定義
一個線程 A 對數據的修改, 可以被另一個線程 B 能立刻訪問到最新的數據, 我們稱之為可見性。
** 緩存一致性問題
由於 cache 是跟 CPU 綁定的, 不同 CPU 間不共用相同的 cache 空間, 如果兩個線程是在不同 CPU 上執行, 且對數據的修改只停留在 cache, 則會有所謂的可見性問題。
* 線程切換, 引入了原子性問題
** 原子性的定義
我們把一個或多個操作在 CPU 中執行的過程中不被中斷的特性稱為原子性。注意, CPU 能保證的原子性是 CPU 指令級別的, 而不是高級語言級別的。
** 任務切換與多路復用
 * OS 為了提供更好的併發性, 允許 CPU 在執行一個 *時間片* 單位後重新選擇一個進程來執行
 * 在一個 *時間片* 內, 如果一個進程要執行 I/O 操作, 這時候該進程會把自己標記為 *休眠* 以出讓 CPU 的使用權, 等待數據抵達內存後, 再由 OS 喚醒該進程。
 * 後來任務切換從基於進程改為更輕量的基於線程
** 任務切換的原子性問題
一個變量被更新, 至少需要 3 條 CPU 指令:
1. 把變量從內存加載到 CPU 的寄存器
2. 在寄存器執行更新操作
3. 覆蓋內存中的變量值

假設線程 A 和線程 B 在不同 CPU 上, 都對變量 x 做 + 1 操作, 我們期望的最終結果是 x 被 +2, 但如果 *任務切換* 發生在指令 1 和 2 之間, 也就是兩個線程加載到的數據都是舊的, 那麼最終的結果是我們不期望的。
* 編譯優化, 引入了有序性問題
** 有序性的定義
為了追求性能, compiler 可能會對指令進行重排, 導致最終結果不是我們期望的。
** 錯誤的 Singleton 案例
#+begin_src java
public class Singleton {
    static Singleton instance;
    static Singleton getInstance () {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null)
                    instance = new Singleton();
            }
        }
        return instance;
    }
}
#+end_src
如果線程 A, B 同時 getInstance, 則只有一個可以真正執行 new, 看起來很完美, 我們認為 compile 後的指令應該是這樣的:
1. 分配一塊內存 M
2. 在 M 上初始化 Singleton 的對象實例
3. 將 M 的位址賦值給 instance 變量

但是實際上 compile 後的指令順序是這樣的:
1. 分配一塊內存 M
2. 將 M 的位址賦值給 instance 變量
3. 在 M 上初始化 Singleton 的對象實例
** 有序性問題
如果線程 A 在執行到第 2 步結束發生了任務切換, 此時變量 instance 並不指向 null 而是指向 M, 但 instance 並未完成初始化, 對於 B 來說可能會觸發空指針異常, 雖然這是發生線程切換導致的異常, 但本質上是因為 compiler 對指令進行重排。
