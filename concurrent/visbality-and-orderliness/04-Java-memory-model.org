#+TITLE: Java Memory Model
上一節我們提到硬件的內存屏障技術, 但是每種不同的 CPU 類型提供內存屏障指令有很大的差異, 因此 JMM 定義了自己一套內存屏障指令, 以封裝底層的變化。 JMM 規範了一套可見性原則, 使得當開發人員遵守這些原則開發時, JMM 會提供相應的抽象的內存屏障指令, 並要求 JVM 為這些指令生成硬件內存屏障指令。
* JMM 基本結構
JMM 最早由 [[http:http://ifeve.com/wp-content/uploads/2014/03/JSR133%E4%B8%AD%E6%96%87%E7%89%881.pdf][JSR-133 Java Memory Model and Thread Specification]] 提出, JMM 規範了一個線程對變量寫入時, 如何確保對其他線程是可見的。 實際上, JMM 提供了合理的禁用 CPU 緩存和重排序的方法, 解決了可見性與有序性問題。 另外, JMM 封裝了硬件和操作系統之間的差異, 保證了 Java 程式極大的遷移能力。

JMM 中的定義的兩個概念:
 * 主內存/共享內存
   用於儲存 Java 的實例對象, 所有線程創建的對象實例存都在共享內存中, 無論這些對象是成員變量還是方法中的本地變量變量. 當然也包含類的信息、常量、靜態變量。 由於是共享存空間, 多個線程對共享變量存取時會有線程安全的問題。
 * 工作內存
   用於儲存當前方法的所有本地變量信息, 當線程使用變量時, 線程會去共享內存中複製一份變量複本到工作內存儲存中, 每個線程只能訪問自己的工作內存, 線程對變量的存取是對自己的工作內存中的複本存取, 也就是一個線程的說工作內存對其他線程來說是不可見的, 即使兩個線程是執行相同代碼, 他們也會在自己的工作內存中創建屬於自己的本地變量, 當然也包含字節碼, 行號指示器, 相關 native 方法的信息。 由於工作內存對其他線程是不可見的, 因此沒有線程安全問題。

JMM 的大致規範如下:
1. 所有變量存在主內存中
2. 每個線程有自己的獨立工作內存, 對變量的搓做都在工作內存中進行
3. 不同內存不能直接訪問彼此的工作內存, 想訪問只能透過主內存來傳遞。
